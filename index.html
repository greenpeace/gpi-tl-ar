<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
	<meta charset="utf-8">
	<meta content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
	<meta name="mobile-web-app-capable" content="yes">
	<title>AR - fur shur</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
	<script src="./js/canvas2image.js"></script>
	<script src='./js/three.min.js'></script>
	<script src="./js/shaders/SSAOShader.js"></script>
	<script src="./js/shaders/CopyShader.js"></script>
	<script src="./js/postprocessing/EffectComposer.js"></script>
	<script src="./js/postprocessing/RenderPass.js"></script>
	<script src="./js/postprocessing/ShaderPass.js"></script>
	<script src="./js/postprocessing/MaskPass.js"></script>
	<script src="./js/postprocessing/SSAOPass.js"></script>
	<script src="./js/OBJLoader.js"></script>
	<script src="./js/MTLLoader.js"></script>
	<script src="./js/ColladaLoader.js"></script>
	<script src="./js/ar.js"></script>
	<script>
		THREEx.ArToolkitContext.baseURL = './'
	</script>
	<style media="screen">
		html,
		body {
			margin: 0;
			width:100%;
			height:100%;
			overflow: hidden;
		}
		#blinds {
			font-family:"Courier New";
			text-align: center;
			font-size:6vw;
			color:white
		}
		#blinds:before {
			content: "";
			display: inline-block;
			height: 75%;
			vertical-align: middle;
		}
	</style>

</head>

<body>
	<button type="submit" id="deleteButton" style="display: block; margin: 0 auto;" onclick="deleteIslands();"><< DELETER >></button>
	<div id="blinds" style="position:absolute;margin:0;width:100%;height:100%;background:rgba(0,0,0,0.7);line-height:100%">
		Find the Marker
		<img style="position:absolute;width:120px;height:120px;margin-left:-60px;margin-top:-10px;left:50%;top:50%;"  src="./assets/gp.png" alt="">
	</div>
	<script>
		//////////////////////////////////////////////////////////////////////////////////
		//		Init
		//////////////////////////////////////////////////////////////////////////////////

		var date;
		var orbitRadius = 7;

		var trees = {
			"tree_little_cone": {
				parent:"island_forest",
			 	scale: [0.01, 0.01, 0.01]
			}
		}

		let islands = {
			"island_forest": {
				position: [-1.2, -0.1, -1.5],
				scale: [0.1, 0.1, 0.1]
			},
			"island_main": {
				position: [1.2, -0.1, 1],
				scale: [0.03, 0.03, 0.03]
			},
			"island_lake": {
				position: [-.5, -0.1, 1.5],
				scale: [0.03, 0.03, 0.03]
			}
		}

		// array of functions for the rendering loop
		var onRenderFcts = [];

		// init scene and camera
		var scene = new THREE.Scene();

		//////////////////////////////////////////////////////////////////////////////////
		//		Initialize a basic camera + lights
		//////////////////////////////////////////////////////////////////////////////////

		// Create a camera
		var camera = new THREE.PerspectiveCamera;
		scene.add(camera);

		// add lights to scene and dynamic camera based light
		var ambientLight = new THREE.AmbientLight(0x212223, 6);
		scene.add(ambientLight);
		var pointLight = new THREE.DirectionalLight(0xffffff, 4);
		pointLight.position.set(-.5, -12, 1.5)
		pointLight.castShadow = true;
		scene.add(pointLight);
		scene.add(pointLight.target);

		// init renderer
		var renderer = new THREE.WebGLRenderer({
			antialias: true,
			alpha: true
		});

		renderer.setPixelRatio(4);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.domElement.style.position = 'absolute';
		renderer.domElement.style.top = '0px';
		renderer.domElement.style.left = '0px';
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;

		renderer.shadowCameraNear = 0.1;
		renderer.shadowCameraFar = 9999999999999;
		renderer.shadowCameraFov = 150;

		renderer.shadowMapBias = 0.0039;
		renderer.shadowMapDarkness = 0.2;
		renderer.shadowMapWidth = 1024;
		renderer.shadowMapHeight = 1024;
		document.body.appendChild(renderer.domElement);


		////////////////////////////////////////////////////////////////////////////////
		//          handle arToolkitSource
		////////////////////////////////////////////////////////////////////////////////

		var arToolkitSource = new THREEx.ArToolkitSource({
			// to read from the webcam
			sourceType: 'webcam',
		})

		arToolkitSource.init(function onReady() {
			onResize()
		})

		// handle resize
		window.addEventListener('resize', function() {
			onResize()
		})

		function onResize() {
			arToolkitSource.onResizeElement();
			arToolkitSource.copyElementSizeTo(renderer.domElement)
			if (arToolkitContext.arController !== null) {
				arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)
			}
		}
		////////////////////////////////////////////////////////////////////////////////
		//          initialize arToolkitContext
		////////////////////////////////////////////////////////////////////////////////


		// create atToolkitContext
		var arToolkitContext = new THREEx.ArToolkitContext({
			cameraParametersUrl: './assets/camera_para.dat',
			detectionMode: 'mono',
			maxDetectionRate: 60,
			canvasWidth: 80 * 3,
			canvasHeight: 60 * 3,
		})
		// initialize it
		arToolkitContext.init(function onCompleted() {
			// copy projection matrix to camera
			camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
		})

		// update artoolkit on every frame
		onRenderFcts.push(function() {
			if (arToolkitSource.ready === false) return
			arToolkitContext.update(arToolkitSource.domElement)
		})


		////////////////////////////////////////////////////////////////////////////////
		//          Create a ArMarkerControls
		////////////////////////////////////////////////////////////////////////////////

		var markerRoot = new THREE.Group
		scene.add(markerRoot)
		var artoolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
			type: 'pattern',
			patternUrl: './assets/patt.gp'
		})

		// build a smoothedControls
		var smoothedRoot = new THREE.Group()
		scene.add(smoothedRoot)
		var smoothedControls = new THREEx.ArSmoothedControls(smoothedRoot, {
			lerpPosition: 0.35,
			lerpQuaternion: 0.18,
			lerpScale: 1,
		})
		onRenderFcts.push(function(delta) {
			smoothedControls.update(markerRoot)
		})
		//////////////////////////////////////////////////////////////////////////////////
		//		add an object in the scene
		//////////////////////////////////////////////////////////////////////////////////

		var arWorldRoot = smoothedRoot;
		arWorldRoot.name = "arWorldRoot" // makes finding it easier

		var geometry = new THREE.SphereGeometry(0.3, 32, 32);
		var material = new THREE.MeshBasicMaterial({
			color: 0xffff00
		});
		var sphere = new THREE.Mesh(geometry, material);
		arWorldRoot.add(sphere);

		let mtlLoader = new THREE.MTLLoader();
		//let objLoader = new THREE.OBJLoader();

		function loadIsland(islandDirectory, islandName) {
			/* something like a docstring
					mtlLoader		 				THREE.MTLLoader instance
					islandDirectory			str, path to directory that contains .mtl, .obj
					islandName					str, the name of the island files
					positions						array of length 3, containing xyz coords for placement
			*/
			mtlLoader.setTexturePath(islandDirectory)
			mtlLoader.setPath(islandDirectory)
			// load material
			mtlLoader.load(islandName + ".mtl", materials => {
				materials.preload()
				let objLoader = new THREE.OBJLoader();
				objLoader.setMaterials(materials)
				objLoader.setPath(islandDirectory)
				// load object
				objLoader.load(islandName + ".obj", object => {
					console.log(`currently loading ${islandName}`)
					console.log(object)
					object.traverse(node => {
						if (node instanceof THREE.Mesh) {
							node.geometry.computeVertexNormals()
						}
					})
					object.scale.set(...islands[islandName].scale)
					object.position.set(...islands[islandName].position) // needs to be an array
					console.log(islands[islandName].scale, islands[islandName])
					object.name = islandName
					arWorldRoot.add(object)
				})
			})
		}
		function loadTreesOnForestIsland(assetDirectory, treesHolder, nr){
			var loadedTrees = [];
			Object.keys(trees).forEach(tree => {
				console.log(tree);
			})
		}
		function loadAssets(assetDirectory, assetName) {
			/* something like a docstring
					assetName 					Name of the Asset to load
					mtlLoader		 				THREE.MTLLoader instance
					islandDirectory			str, path to directory that contains .mtl, .obj
					islandName					str, the name of the island files
					positions						array of length 3, containing xyz coords for placement
			*/
			mtlLoader.setTexturePath(assetDirectory)
			mtlLoader.setPath(assetDirectory)
			// load material
			mtlLoader.load(assetName + ".mtl", materials => {
				materials.preload()
				let objLoader = new THREE.OBJLoader();
				objLoader.setMaterials(materials)
				objLoader.setPath(assetDirectory)
				// load object
				objLoader.load(assetName + ".obj", object => {
					console.log(`currently loading ${assetName}`)
					console.log(object)
					object.traverse(node => {
						if (node instanceof THREE.Mesh) {
							node.geometry.computeVertexNormals()
						}
					})
					object.scale.set(...trees[assetName].scale)
					object.position.set(-1.7+(Math.random()*0.5), 0.4, -1.25+(Math.random()*0.3))
					console.log(trees[assetName])
					object.name = assetName
					arWorldRoot.add(object)
				})
			})
		}

		// iterate over all islands
		Object.keys(islands).forEach(island => {
			loadIsland("./assets/islands/", island)
		})

		// iterate over all trees
		// Object.keys(trees).forEach(tree => {
		// 	for (var i = 0; i < 50; i++) {
		// 		loadAssets("./assets/trees/", tree)
		// 	}
		// })


		//////////////////////////////////////////////////////////////////////////////////
		//		render the whole thing on the page
		//////////////////////////////////////////////////////////////////////////////////

		// render the scene
		onRenderFcts.push(function() {
			renderer.render(scene, camera);
		})

		// object foo
		let islandDirections = {
			"island_forest": 1,
			"island_main": 1,
			"island_lake": 1
		}

		// run the rendering loop
		var lastTimeMsec = null
		requestAnimationFrame(function animate(nowMsec) {
			// keep looping
			requestAnimationFrame(animate);
			// lift or lower blinds based on whether marker is visible or not.
			if (markerRoot.visible) {
				$("#blinds").fadeOut(100)
			} else {
				$("#blinds").fadeIn()
			}
			// measure time
			lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
			var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
			lastTimeMsec = nowMsec
			// call each update function
			onRenderFcts.forEach(function(onRenderFct) {
				onRenderFct(deltaMsec / 1000, nowMsec / 1000)
			})

			// iterate over all available islands
			let availableIslands = []
			// push all available islands to array
			scene.getObjectByName(arWorldRoot.name).children.forEach(obj => {
				if (obj.name !== "") {
					availableIslands.push(obj.name)
				}
			})

			// actual iteration
			availableIslands.forEach(island => {
				let islandModel = model(island)
				let dir = 1 // short direction variable name for convenience
				// switch-case:
				switch (island) {
					case "island_forest":
						if (islandModel.position.y < 0) {
							islandDirections[island] = 1
						} else if (islandModel.position.y > 0.4) {
							islandDirections[island] = -1
						}
						dir = islandDirections[island]
						islandModel.position.set(islandModel.position.x,
							islandModel.position.y + 0.001 * dir,
							islandModel.position.z)
							for (var i = 0; i < arWorldRoot.children.length; i++) {
								if(arWorldRoot.children[i].name=="tree_little_cone"){
									arWorldRoot.children[i].position.set(arWorldRoot.children[i].position.x,
										islandModel.position.y + 0.001 * dir,
										arWorldRoot.children[i].position.z)
								}
							}
						break;

					case "island_main":
						if (islandModel.position.y < 0) {
							islandDirections[island] = 1
						} else if (islandModel.position.y > 0.2) {
							islandDirections[island] = -1
						}
						dir = islandDirections[island]
						islandModel.position.set(islandModel.position.x,
							islandModel.position.y + 0.002 * dir,
							islandModel.position.z)
						break;

					case "island_lake":
						if (islandModel.position.y < 0) {
							islandDirections[island] = 1
						} else if (islandModel.position.y > 0.6) {
							islandDirections[island] = -1
						}
						dir = islandDirections[island]
						islandModel.position.set(islandModel.position.x,
							islandModel.position.y + 0.003 * dir,
							islandModel.position.z)
						break;

					default:
						//console.log(`entered default case for variable ${island}.`)
				}
			})
			date = Date.now() * 0.0002;
			pointLight.position.set(
				Math.cos(date) * orbitRadius,
				Math.sin(date) * orbitRadius,
				Math.sin(date) * orbitRadius
			);
			sphere.position.set(
				Math.cos(date) * orbitRadius,
				Math.sin(date) * orbitRadius,
				Math.sin(date) * orbitRadius
			);
			//console.log(pointLight.position);
		})

		function animate() {
			console.log("placeholder function cause gabe forgot")
		}
		//Island Deleter
		function deleteIslands() {
			for (var i = 0; i < arWorldRoot.children.length; i++) {
				if (arWorldRoot.children[i].name) {
					var toRemove = model(arWorldRoot.children[i].name);
					arWorldRoot.remove( toRemove );
					// animate();
	      }
	    }
		}

		function setGrassGreenness(greenness) {
			model("island_forest").children[0].material.color.r = 1 - greenness;
			model("island_forest").children[0].material.color.g = greenness * .7 + 0.3;
		}

		function setWaterClarity(clarity) {
			model("island_forest").children[0].material.color.r = 0;
			model("island_forest").children[0].material.color.g = clarity * 0.2;
			model("island_forest").children[0].material.color.b = clarity;
			model("island_forest").children[0].material.opacity = 1 - clarity * .3;
		}

		function model(name) {
			for (var i = 0; i < arWorldRoot.children.length; i++) {
				if (arWorldRoot.children[i].name == name) {
					return arWorldRoot.children[i];
				}
			}
		}
	</script>
</body>
</html>
